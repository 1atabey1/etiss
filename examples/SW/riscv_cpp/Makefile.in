#
#	Copyright 2018 Infineon Technologies AG
#
#	This file is part of ETISS tool, see <https://gitlab.lrz.de/de-tum-ei-eda-open/etiss>
#
#	The initial version of this software has been created with the funding support by the German Federal
#	Ministry of Education and Research(BMBF) in the project EffektiV under grant 01IS13022.
#
#	Redistribution and use in source and binary forms, with or without modification, are permitted
#	provided that the following conditions are met:
#
#	1. Redistributions of source code must retain the above copyright notice, this list of conditions and
#	the following disclaimer.
#
# 	2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions
#	and the following disclaimer in the documentation and / or other materials provided with the distribution.
#
# 	3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse
# 	or promote products derived from this software without specific prior written permission.
#
#	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
#	WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
#	PARTICULAR PURPOSE ARE DISCLAIMED.IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
#	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
#	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING
#	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#	POSSIBILITY OF SUCH DAMAGE.
#
#
#	Author: Marc Greim <marc.greim@mytum.de>, Chair of Electronic Design Automation, TUM
#
#	Version 0.3
#

# This Makefile is used by the ETISS SW-example and the systemC example,
# which has its own software.

TOOLBUILD ?= rvtc-ilp32-multlib-1.0.0.0
ifeq ($(TOOLBIN),)
ifeq ($(shell uname),Linux)
   ifeq ($(shell lsb_release -is),RedHatEnterpriseServer)
       TOOL_INSTALL_ROOT=/home/aifordes.work/share
   else
       TOOL_INSTALL_ROOT=/opt
   endif
else
    TOOL_INSTALL_ROOT=/c/Inicio/tools/64
endif
TOOLBIN:=$(TOOL_INSTALL_ROOT)/$(TOOLBUILD)/bin
endif


ROM_SIZE_KB ?= 4096
RAM_SIZE_KB ?= 1024
STACK_SIZE_KB ?= 128
GCC_BUILD_VARIANT=riscv32-unknown-elf
TARGET_ABI ?= ilp32
TARGET_ARCH ?= rv32imac
TARGET_ELF_FMT=elf32-littleriscv
LD_EMULATION=elf32lriscv

define path_prefix_call =
@echo $(1)
@$(SET_PATH) $(1)
endef

BARE_METAL_FLAGS= -fno-builtin  -ffreestanding
BARE_METAL_LIBS=$(LIBS_OBJ) 
BARE_METAL_LDFLAGS=-nostartfiles  -T ${SW_DIR_RISCV}/link.ld 
BARE_METAL_OBJS=$(BOOT_ENTRY_OBJ)
SET_PATH=PATH='$(TOOLBIN):$(PATH)'


PATHED_RISCVCC=$(SET_PATH) $(RISCVCC)
RISCVCC=$(TOOLBIN)/$(GCC_BUILD_VARIANT)-gcc -mabi=$(TARGET_ABI) -march=$(TARGET_ARCH)  $(BARE_METAL_FLAGS)
RISCVCPP=$(TOOLBIN)/$(GCC_BUILD_VARIANT)-g++  -march=$(TARGET_ARCH) -mabi=$(TARGET_ABI)  $(BARE_METAL_FLAGS)
PATHED_RISCVCPP=$(SET_PATH) $(RISCVCPP)
RISCVOBJCPY=$(TOOLBIN)/$(GCC_BUILD_VARIANT)-objcopy
RISCVOBJDMP= $(TOOLBIN)/$(GCC_BUILD_VARIANT)-objdump
RISCVRDELF=$(TOOLBIN)/$(GCC_BUILD_VARIANT)-readelf
RISCVSIZE=$(TOOLBIN)/$(GCC_BUILD_VARIANT)-size
RISCVLD=$(TOOLBIN)/$(GCC_BUILD_VARIANT)-ld
PATHED_RISCVLD=$(SET_PATH) $(RISCVLD)


DEBUG?=1

ifeq ($(DEBUG),0)
	DBGPARAM =
	OPTLEVEL?=-O3
else
	DBGPARAM =-g
	OPTLEVEL?=-O0
endif

# The following paths will be inserted by CMake while installing ETISS.
# As they are absolute, it doesn't matter where the Makefile is executed,
# the only condition is that main.c lies in the same directory as this Makefile.

# The object and executable files will be put in the obj and build
# subdirectories, respectively.

SW_DIR = $(dir $(CURDIR))
SW_DIR_TCS = $(SW_DIR)/test_cases/
SW_DIR_RISCV = $(SW_DIR)/riscv_cpp/

BUILD_DIR = ./build
OBJECT_DIR = ./obj
C_CXX_FLAGS =  $(OPTLEVEL)  -I ${SW_DIR} -I ${SW_DIR}/sys_lib/inc -I ${SW_DIR}/string_lib/inc 
CFLAGS = $(DBGPARAM) $(C_CXX_FLAGS) -std=gnu99
CXXFLAGS = $(DBGPARAM) $(C_CXX_FLAGS)
LDFLAGS = $(BARE_METAL_LDFLAGS)  -Wl,--no-relax $(DBGPARAM) $(C_CXX_FLAGS)

all: mkdirs romram


mkdirs:
	mkdir -p $(BUILD_DIR)
	mkdir -p $(OBJECT_DIR)

#Note: Add other source files here.



SYS_LIB_FILES = int.c uart.c exceptions.c
SYSLIB_OBJ = ${SYS_LIB_FILES:%.c=$(OBJECT_DIR)/%.o}

BOOT_ENTRY = crt0.riscv
BOOT_ENTRY_SRC = ${SW_DIR_RISCV}/$(BOOT_ENTRY).S



LIBS_OBJ = \
	$(OBJECT_DIR)/sys_lib.o \
	$(OBJECT_DIR)/syscalls.o \
	#$(OBJECT_DIR)/atomic.o  \
	#$(OBJECT_DIR)/string_lib.o

BOOT_ENTRY_OBJ = $(OBJECT_DIR)/$(BOOT_ENTRY).o
MAIN_OBJ = $(OBJECT_DIR)/main.o

$(BOOT_ENTRY_OBJ): $(BOOT_ENTRY_SRC)
	$(call path_prefix_call, $(RISCVCC) $(C_CXX_FLAGS) -c ${BOOT_ENTRY_SRC} -o $@) 

${BUILD_DIR}/code.elf: $(BARE_METAL_OBJS) $(MAIN_OBJ) $(BARE_METAL_LIBS) Makefile
	sed -e'1,$$s/%%RAM_SIZE_KB%%/$(RAM_SIZE_KB)/g' -e'1,$$s/%%ROM_SIZE_KB%%/$(ROM_SIZE_KB)/g' -e'1,$$s/%%STACK_SIZE_KB%%/$(STACK_SIZE_KB)/g' link.ld.templ > link.ld
	$(call path_prefix_call, $(RISCVCPP) $(LDFLAGS) ${BARE_METAL_OBJS} $(MAIN_OBJ) ${BARE_METAL_LIBS} -o ${BUILD_DIR}/code.elf)
	$(RISCVSIZE) ${BUILD_DIR}/code.elf



${BUILD_DIR}/code.bin: ${BUILD_DIR}/code.elf
	$(call path_prefix_call, $(RISCVOBJCPY) ${BUILD_DIR}/code.elf --output-target=binary ${BUILD_DIR}/code.bin)

${BUILD_DIR}/code.disasm: ${BUILD_DIR}/code.elf
	$(call path_prefix_call, $(RISCVOBJDMP) -S -D ${BUILD_DIR}/code.elf > ${BUILD_DIR}/code.disasm)

${BUILD_DIR}/code.txt: ${BUILD_DIR}/code.elf
	@echo CODE
	$(call path_prefix_call, $(RISCVRDELF) -a ${BUILD_DIR}/code.elf > ${BUILD_DIR}/code.txt)

# This generates a seperate file to go into rom and ram memory
# The offsets must corespond to the offsets in the linker script converted to decimal
# Example: linker script rom size 0x0080000 = count=524288 (copies beginning of hex file for rom)
# 	   linker script ram begins at 0x18000000 = skip=402653184 (copies everything starting from 0x18000000)
romram: $(BUILD_DIR)/code.ram $(BUILD_DIR)/code.rom

$(BUILD_DIR)/code.rom: ${BUILD_DIR}/code.bin 
	dd bs=1024 count=$(ROM_SIZE_KB) if=$(BUILD_DIR)/code.bin of=$(BUILD_DIR)/code.rom
	
$(BUILD_DIR)/code.ram:  ${BUILD_DIR}/code.bin
	dd bs=1024 skip=$(ROM_SIZE_KB) if=$(BUILD_DIR)/code.bin of=$(BUILD_DIR)/code.ram



$(OBJECT_DIR)/syscalls.o: syscalls.c
	@echo $(RISCVCC) $(CFLAGS) -c $< -o $@
	@$(PATHED_RISCVCC) $(CFLAGS) -c $< -o $@
	
$(OBJECT_DIR)/atomic.o: atomic.c
	@echo $(RISCVCC) $(CFLAGS) -c $< -o $@
	@$(PATHED_RISCVCC) $(CFLAGS) -c $< -o $@

$(MAIN_OBJ): main.cpp
	$(call path_prefix_call, $(RISCVCPP) -g $(C_CXX_FLAGS) -c $< -o $@)


$(OBJECT_DIR)/%.o: ${SW_DIR}/sys_lib/src/%.c
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)



$(OBJECT_DIR)/sys_lib.o: ${SYSLIB_OBJ}
	$(call path_prefix_call,$(RISCVLD) -r $^ -o $@)


#$(OBJECT_DIR)/string_lib.o: ${STRINGLIB_SRC} $(OBJECT_DIR)/sys_lib.o
#	$(PATHED_RISCVCC) $(CFLAGS) -o $@ -c $^

clean:
	rm -rf $(OBJECT_DIR)
	rm -rf ${BUILD_DIR}
