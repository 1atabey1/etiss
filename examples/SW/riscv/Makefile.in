#
#	Copyright 2018 Infineon Technologies AG
#
#	This file is part of ETISS tool, see <https://gitlab.lrz.de/de-tum-ei-eda-open/etiss>
#
#	The initial version of this software has been created with the funding support by the German Federal
#	Ministry of Education and Research(BMBF) in the project EffektiV under grant 01IS13022.
#
#	Redistribution and use in source and binary forms, with or without modification, are permitted
#	provided that the following conditions are met:
#
#	1. Redistributions of source code must retain the above copyright notice, this list of conditions and
#	the following disclaimer.
#
# 	2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions
#	and the following disclaimer in the documentation and / or other materials provided with the distribution.
#
# 	3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse
# 	or promote products derived from this software without specific prior written permission.
#
#	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED
#	WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
#	PARTICULAR PURPOSE ARE DISCLAIMED.IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY
#	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES(INCLUDING, BUT NOT LIMITED TO,
#	PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
#	HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT(INCLUDING
#	NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#	POSSIBILITY OF SUCH DAMAGE.
#
#
#	Author: Marc Greim <marc.greim@mytum.de>, Chair of Electronic Design Automation, TUM
#
#	Version 0.1
#

# This Makefile is used by the ETISS SW-example and the systemC example,
# which has its own software.

TOOLBUILD ?= rvtc-ilp32-multlib-1.0.0.0
ifeq ($(TOOLBIN),)
ifeq ($(shell uname),Linux)
   ifeq ($(shell lsb_release -is),RedHatEnterpriseServer)
       TOOL_INSTALL_ROOT=/home/aifordes.work/share
   else
       TOOL_INSTALL_ROOT=/opt
   endif
else
    TOOL_INSTALL_ROOT=/c/Inicio/tools/64
endif
TOOLBIN:=$(TOOL_INSTALL_ROOT)/$(TOOLBUILD)/bin
endif

RAM_SIZE_KB ?= 1024
ROM_SIZE_KB ?= 4096
STACK_SIZE_KB ?= 128

SOFTFLOAT?=0

ifeq ($(SOFTFLOAT),1)
	FLOATTYPE= -mhard-float
else
	FLOATTYPE= -msoft-float
endif

SET_PATH=PATH="$(TOOLBIN):$(PATH)"


RISCVCC= $(TOOLBIN)/riscv32-unknown-elf-gcc -march=rv32imac -nostartfiles  -fno-builtin  -ffreestanding
RISCVOBJCPY= $(TOOLBIN)/riscv32-unknown-elf-objcopy
RISCVOBJDMP= $(TOOLBIN)/riscv32-unknown-elf-objdump
RISCVRDELF= $(TOOLBIN)/riscv32-unknown-elf-readelf
RISCVLD= $(TOOLBIN)/riscv32-unknown-elf-ld


DEBUG?=1

ifeq ($(DEBUG),0)
	DBGPARAM =
	OPTLEVEL?=-O3
else
	DBGPARAM =-g
	OPTLEVEL?=-O3
endif

# The following paths will be inserted by CMake while installing ETISS.
# As they are absolute, it doesn't matter where the Makefile is executed,
# the only condition is that main.c lies in the same directory as this Makefile.

# The object and executable files will be put in the obj and build
# subdirectories, respectively.

SW_DIR = $(dir $(CURDIR))
SW_DIR_TCS = $(SW_DIR)/test_cases/
SW_DIR_RISCV = $(SW_DIR)/riscv/

BUILD_DIR = ./build
OBJECT_DIR = ./obj
CFLAGS = $(DBGPARAM) $(OPTLEVEL)  -T ${SW_DIR_RISCV}/link.ld -I ${SW_DIR} -I ${SW_DIR}/sys_lib/inc -I ${SW_DIR}/string_lib/inc -std=gnu99


all: mkdirs ${BUILD_DIR}/code.elf ${BUILD_DIR}/code.bin ${BUILD_DIR}/code.txt ${BUILD_DIR}/code.disasm romram


mkdirs:
	mkdir -p $(BUILD_DIR)
	mkdir -p $(OBJECT_DIR)



SYS_LIB_FILES = int.c uart.c exceptions.c
SYSLIB_OBJ = ${SYS_LIB_FILES:%.c=$(OBJECT_DIR)/%.o}

BOOT_ENTRY = ${SW_DIR_RISCV}/crt0.riscv.S

TEST_OBJ = \
  ${OBJECT_DIR}/print_.o \
  ${OBJECT_DIR}/aes_.o \
  ${OBJECT_DIR}/edge_.o \
  ${OBJECT_DIR}/fir_.o \
  ${OBJECT_DIR}/iir_.o \
  ${OBJECT_DIR}/pi_.o \
  ${OBJECT_DIR}/heap_.o \
  ${OBJECT_DIR}/isort_.o \
  ${OBJECT_DIR}/jdct_.o \
  ${OBJECT_DIR}/test_.o  \

LIBS_OBJ = \
	${OBJECT_DIR}/sys_lib.o \
	${OBJECT_DIR}/syscalls.o \
	#${OBJECT_DIR}/string_lib.o

define path_prefix_call =
@echo $(1)
@$(SET_PATH) $(1)
endef

${BUILD_DIR}/code.elf: mkdirs main.c ${BOOT_ENTRY} ${TEST_OBJ} ${LIBS_OBJ}
	sed -e'1,$$s/%%RAM_SIZE_KB%%/$(RAM_SIZE_KB)/g' -e'1,$$s/%%ROM_SIZE_KB%%/$(ROM_SIZE_KB)/g' -e'1,$$s/%%STACK_SIZE_KB%%/$(STACK_SIZE_KB)/g' link.ld.templ > link.ld
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) ${BOOT_ENTRY} main.c -o ${BUILD_DIR}/code.elf ${TEST_OBJ} ${LIBS_OBJ})

${BUILD_DIR}/code.bin: ${BUILD_DIR}/code.elf
	$(call path_prefix_call, $(RISCVOBJCPY) ${BUILD_DIR}/code.elf --output-target=binary ${BUILD_DIR}/code.bin)

${BUILD_DIR}/code.disasm: ${BUILD_DIR}/code.elf
	$(call path_prefix_call, $(RISCVOBJDMP) -S -D ${BUILD_DIR}/code.elf > ${BUILD_DIR}/code.disasm)

${BUILD_DIR}/code.txt: ${BUILD_DIR}/code.elf
	$(call path_prefix_call, $(RISCVRDELF) -a ${BUILD_DIR}/code.elf > ${BUILD_DIR}/code.txt)

# This generates a seperate file to go into rom and ram memory
# The offsets must corespond to the offsets in the linker script converted to decimal
# Example: linker script rom size 0x0080000 = count=524288 (copies beginning of hex file for rom)
# 	   linker script ram begins at 0x18000000 = skip=402653184 (copies everything starting from 0x18000000)
romram: ${BUILD_DIR}/code.bin
	dd bs=1024 count=$(ROM_SIZE_KB) if=$(BUILD_DIR)/code.bin of=$(BUILD_DIR)/code.rom
	dd bs=1024 skip=$(ROM_SIZE_KB) if=$(BUILD_DIR)/code.bin of=$(BUILD_DIR)/code.ram



${OBJECT_DIR}/print_.o: ${SW_DIR_TCS}/cust_print/cust_print.c
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/aes_.o: ${SW_DIR_TCS}/aes/aes.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/edge_.o: ${SW_DIR_TCS}/edge/edge.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/fir_.o: ${SW_DIR_TCS}/fir/fir.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/iir_.o: ${SW_DIR_TCS}/iir/iir.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/heap_.o: ${SW_DIR_TCS}/heap/heap.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/isort_.o: ${SW_DIR_TCS}/isort/isort.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/jdct_.o: ${SW_DIR_TCS}/jdct/jdct.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/pi_.o: ${SW_DIR_TCS}/pi/pi.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/test_.o: ${SW_DIR_TCS}/simple_tests/test.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/syscalls.o: syscalls.c
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)


$(OBJECT_DIR)/%.o: ${SW_DIR}/sys_lib/src/%.c
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)


$(OBJECT_DIR)/sys_lib.o: $(SYSLIB_OBJ)
	$(call path_prefix_call, $(RISCVLD) -r $^ -o $@)



#${OBJECT_DIR}/string_lib.o: ${STRINGLIB_SRC} $(OBJECT_DIR)/sys_lib.o
#	$(RISCVCC) $(CFLAGS) -o $@ -c $^

clean:
	rm -rf $(OBJECT_DIR)
	rm -rf ${BUILD_DIR}
