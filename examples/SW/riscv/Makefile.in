
TOOLBUILD ?= rvtc-ilp32-multlib-1.0.0.0
ifeq ($(TOOLBIN),)

ifeq ($(shell uname),Linux)
   ifeq ($(shell lsb_release -is),RedHatEnterpriseServer)
       TOOL_INSTALL_ROOT=/home/aifordes.work/share
   else
       TOOL_INSTALL_ROOT=/opt
   endif
else
    TOOL_INSTALL_ROOT=/c/Inicio/tools/64
endif
TOOLBIN:=$(TOOL_INSTALL_ROOT)/$(TOOLBUILD)/bin
endif

RAM_SIZE_KB ?= 1024
ROM_SIZE_KB ?= 4096
STACK_SIZE_KB ?= 128

SOFTFLOAT?=0

ifeq ($(SOFTFLOAT),1)
	FLOATTYPE= -mhard-float
else
	FLOATTYPE= -msoft-float
endif

SET_PATH=PATH="$(TOOLBIN):$(PATH)"


RISCVCC= $(TOOLBIN)/riscv32-unknown-elf-gcc -march=rv32imfd -nostartfiles  -fno-builtin  -ffreestanding
RISCVOBJCPY= $(TOOLBIN)/riscv32-unknown-elf-objcopy
RISCVOBJDMP= $(TOOLBIN)/riscv32-unknown-elf-objdump
RISCVRDELF= $(TOOLBIN)/riscv32-unknown-elf-readelf
RISCVLD= $(TOOLBIN)/riscv32-unknown-elf-ld


DEBUG?=1

ifeq ($(DEBUG),0)
	DBGPARAM =
	OPTLEVEL?=-O3
else
	DBGPARAM =-g
	OPTLEVEL?=-O3
endif

# The following paths will be inserted by CMake while installing ETISS.
# As they are absolute, it doesn't matter where the Makefile is executed,
# the only condition is that main.c lies in the same directory as this Makefile.

# The object and executable files will be put in the obj and build
# subdirectories, respectively.

SW_DIR = $(dir $(CURDIR))
SW_DIR_TCS = $(SW_DIR)/test_cases/
SW_DIR_RISCV = $(SW_DIR)/riscv_cpp/

BUILD_DIR = ./build
OBJECT_DIR = ./obj
CFLAGS = $(DBGPARAM) $(OPTLEVEL)  -T ${SW_DIR_RISCV}/link.ld -I ${SW_DIR} -I ${SW_DIR}/sys_lib/inc -I ${SW_DIR}/string_lib/inc -std=gnu99


all: mkdirs ${BUILD_DIR}/code.elf ${BUILD_DIR}/code.bin ${BUILD_DIR}/code.txt ${BUILD_DIR}/code.disasm romram

#This is to download sys_lib , string_lib , and additional instruction tests from Pulpino
getlib:
	svn checkout https://github.com/pulp-platform/pulpino/trunk/sw/libs/sys_lib
	svn checkout https://github.com/pulp-platform/pulpino/trunk/sw/libs/string_lib
	svn checkout https://github.com/cliffordwolf/picorv32/trunk/tests instr_tests

mkdirs:
	mkdir -p $(BUILD_DIR)
	mkdir -p $(OBJECT_DIR)

#Note: Add other source files here.
SYSLIB_SRC = ${SW_DIR}/sys_lib/src/int.c \
	     ${SW_DIR}/sys_lib/src/uart.c \
	     ${SW_DIR}/sys_lib/src/exceptions.c# $(wildcard ${SW_DIR}/sys_lib/src/*.c)

SYSLIB_OBJ = ${SYSLIB_SRC:.c=.o}

BOOT_ENTRY = ${SW_DIR_RISCV}/crt0.riscv.S

TEST_OBJ = \
  ${OBJECT_DIR}/print_.o \
  ${OBJECT_DIR}/aes_.o \
  ${OBJECT_DIR}/edge_.o \
  ${OBJECT_DIR}/fir_.o \
  ${OBJECT_DIR}/iir_.o \
  ${OBJECT_DIR}/pi_.o \
  ${OBJECT_DIR}/heap_.o \
  ${OBJECT_DIR}/isort_.o \
  ${OBJECT_DIR}/jdct_.o \
  ${OBJECT_DIR}/test_.o  \

LIBS_OBJ = \
	${OBJECT_DIR}/sys_lib.o \
	${OBJECT_DIR}/syscalls.o \
	#${OBJECT_DIR}/string_lib.o

define path_prefix_call =
@echo $(1)
@$(SET_PATH) $(1)
endef

${BUILD_DIR}/code.elf: mkdirs main.c ${BOOT_ENTRY} ${TEST_OBJ} ${LIBS_OBJ}
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) ${BOOT_ENTRY} main.c -o ${BUILD_DIR}/code.elf ${TEST_OBJ} ${LIBS_OBJ})

${BUILD_DIR}/code.bin: ${BUILD_DIR}/code.elf
	$(call path_prefix_call, $(RISCVOBJCPY) ${BUILD_DIR}/code.elf --output-target=binary ${BUILD_DIR}/code.bin)

${BUILD_DIR}/code.disasm: ${BUILD_DIR}/code.elf
	$(call path_prefix_call, $(RISCVOBJDMP) -S -D ${BUILD_DIR}/code.elf > ${BUILD_DIR}/code.disasm)

${BUILD_DIR}/code.txt: ${BUILD_DIR}/code.elf
	$(call path_prefix_call, $(RISCVRDELF) -a ${BUILD_DIR}/code.elf > ${BUILD_DIR}/code.txt)

# This generates a seperate file to go into rom and ram memory
# The offsets must corespond to the offsets in the linker script converted to decimal
# Example: linker script rom size 0x0080000 = count=524288 (copies beginning of hex file for rom)
# 	   linker script ram begins at 0x18000000 = skip=402653184 (copies everything starting from 0x18000000)
romram: ${BUILD_DIR}/code.bin
	dd bs=1024 count=$(ROM_SIZE_KB) if=$(BUILD_DIR)/code.bin of=$(BUILD_DIR)/code.rom
	dd bs=1024 skip=$(ROM_SIZE_KB) if=$(BUILD_DIR)/code.bin of=$(BUILD_DIR)/code.ram



${OBJECT_DIR}/print_.o: ${SW_DIR_TCS}/cust_print/cust_print.c
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/aes_.o: ${SW_DIR_TCS}/aes/aes.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/edge_.o: ${SW_DIR_TCS}/edge/edge.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/fir_.o: ${SW_DIR_TCS}/fir/fir.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/iir_.o: ${SW_DIR_TCS}/iir/iir.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/heap_.o: ${SW_DIR_TCS}/heap/heap.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/isort_.o: ${SW_DIR_TCS}/isort/isort.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/jdct_.o: ${SW_DIR_TCS}/jdct/jdct.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/pi_.o: ${SW_DIR_TCS}/pi/pi.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/test_.o: ${SW_DIR_TCS}/simple_tests/test.c ${OBJECT_DIR}/print_.o
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${OBJECT_DIR}/syscalls.o: syscalls.c
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -c $< -o $@)

${SW_DIR}/sys_lib/src/%.o: ${SW_DIR}/sys_lib/src/%.c
	rm -f $@
	$(call path_prefix_call, $(RISCVCC) $(CFLAGS) -o $@ -c $<)

${OBJECT_DIR}/sys_lib.o: ${SYSLIB_OBJ}
	$(call path_prefix_call, $(RISCVLD) -r $^ -o $@)
	rm -f ${SYSLIB_OBJ}


#${OBJECT_DIR}/string_lib.o: ${STRINGLIB_SRC} ${OBJECT_DIR}/sys_lib.o
#	$(RISCVCC) $(CFLAGS) -o $@ -c $^

clean:
	rm -rf ${OBJECT_DIR}
	rm -rf ${BUILD_DIR}
	rm -f ${SYSLIB_OBJ}
